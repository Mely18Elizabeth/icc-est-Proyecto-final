# üß≠ Implementaci√≥n de un Algoritmo para Encontrar la Ruta √ìptima en un Laberinto

Aplicando **Programaci√≥n Din√°mica** y **Estructuras de Datos**
Nombres:
- Melany Elizabeth Pintado Pilco
- Janelly Dayanna Chacha V√©lez

Url presentacion: https://www.canva.com/design/DAGumSrUm7U/R_xAzxu_ZTACdf_M2-X0AQ/edit?utm_content=DAGumSrUm7U&utm_campaign=designshare&utm_medium=link2&utm_source=sharebutton
---

## üéØ Objetivo

Desarrollar una aplicaci√≥n que implemente un algoritmo para encontrar la ruta √≥ptima desde un punto de inicio (A) hasta un punto de destino (B) en un laberinto, utilizando conceptos avanzados de **programaci√≥n din√°mica**, y estructuras de datos **lineales** y **no lineales**.

---
<img width="830" height="363" alt="cap1" src="https://github.com/user-attachments/assets/0b31e38f-719b-457f-8921-16054404c720" />


## üñºÔ∏è Vista Previa


---

<img width="1177" height="622" alt="cap2" src="https://github.com/user-attachments/assets/1853fa41-da08-49b2-af60-f89668b850a7" />


---
## üñºÔ∏è Diagrama UML


<img width="952" height="882" alt="cap3Diagrama" src="https://github.com/user-attachments/assets/5f4e8245-fbb7-45e5-be33-4e40ee11c527" />


---

## ‚úÖ Conclusiones

1. La implementaci√≥n de algoritmos de resoluci√≥n de laberintos permiti√≥ evidenciar la importancia de las estructuras de datos adecuadas (como colas, pilas y grafos) para optimizar el recorrido y encontrar soluciones eficientes en problemas de caminos.

2. El uso de programaci√≥n din√°mica y t√©cnicas como backtracking y b√∫squeda en profundidad o anchura permiti√≥ comparar distintos enfoques, demostrando que no existe un √∫nico algoritmo √≥ptimo, sino que su eficacia depende de la estructura del laberinto y del objetivo deseado (camino m√°s corto, menor costo, etc.).

---

## üí° Recomendaciones

1. Optimizar el uso de recursos y estructuras de datos para laberintos grandes, ya que algunos algoritmos pueden consumir mucha memoria o tiempo de ejecuci√≥n si no se manejan correctamente.

2. Mejorar la interfaz gr√°fica y a√±adir m√°s interactividad, como permitir al usuario editar el laberinto manualmente o ver paso a paso c√≥mo avanza el algoritmo, lo cual mejora la comprensi√≥n del funcionamiento interno.

